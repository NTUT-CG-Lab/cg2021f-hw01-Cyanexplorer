<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loader - ttf</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			Drag file to the screen for your model to display.
		</div>

		<script src="./opentype.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="./PLYLoader.js"></script>
		<script src="./TTFLoader.js"></script>

		<script>

			let container;
			let camera, cameraTarget, scene, renderer;
			let group, textMesh1, textMesh2, textGeo, material;
			let second, minute, hours, object, touchGroup
			let firstLetter = true;
			let opstate = -1
			let velocity = new THREE.Vector3(1, 1, 0)

			let aspect = window.innerWidth / window.innerHeight

			let x_limit_l = 75 * aspect
			let x_limit_r = -75 * aspect
			let y_limit_t = 75 + 40
			let y_limit_b = -75 + 40

			let raycaster
			const mouse = new THREE.Vector2();

			let text = '高等計算機圖學作業';
			const height = 2,
				size = 8,
				hover = 0,
				curveSegments = 12,
				bevelThickness = 1,
				bevelSize = 1;

			let font = null;
			const mirror = false;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			window.onload = function () {

				const loader = new THREE.TTFLoader();
				loader.load('./fonts/MoeLI.ttf', function (json) {
					console.log(json)
					font = new THREE.Font(json);

					init();
					animate();
				});
			}

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				// CAMERA

				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
				camera.position.set(0, 40, 130);

				cameraTarget = new THREE.Vector3(0, 40, 0);

				// SCENE

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x000000);
				scene.fog = new THREE.Fog(0x000000, 250, 1400);

				// LIGHTS

				const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
				dirLight.position.set(0, 0, 1).normalize();
				scene.add(dirLight);

				const pointLight = new THREE.PointLight(0xffffff, 0.8);
				pointLight.position.set(0, 100, 90);
				pointLight.color.setHSL(Math.random(), 1, 0.5);
				scene.add(pointLight);

				material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });

				group = new THREE.Group();
				group.position.y = 0;

				scene.add(group);

				createText();

				const plane = new THREE.Mesh(
					new THREE.PlaneGeometry(120, 120),
					new THREE.MeshBasicMaterial({ color: 0xBBBBBB })
				);
				//plane.position.y = 100;
				plane.rotation.x = - Math.PI / 2;
				group.add(plane);

				// RENDERER

				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				// RAYCASTER

				raycaster = new THREE.Raycaster();
				raycaster.far = 200
				raycaster.near = 1
				raycaster.layers.set(1)

				// EVENTS

				container.addEventListener('mousedown', onPointerDown);
                container.addEventListener('dragover', (evt) => {
                    evt.preventDefault()
                })
				container.addEventListener('drop', (evt) => {
					evt.preventDefault()
                    let files = evt.dataTransfer.files;
					console.log(files[0])

					let reader = new FileReader()
					reader.onload = () => {
						createObject(reader.result)
					}
					reader.readAsDataURL(files[0])
					
                })

				document.addEventListener('keypress', onDocumentKeyPress);
				document.addEventListener('keydown', onDocumentKeyDown);

				window.addEventListener('resize', onWindowResize);
				
				// Object
				createClock()
			}

            function createObject(path = './Lucy100k.ply') {
				let loader = new THREE.PLYLoader()
                loader.load(path, (geometry) => {

					geometry.computeBoundingBox()
					geometry.computeVertexNormals()
					let xLength = geometry.boundingBox.max.x - geometry.boundingBox.min.x
                    let yLength = geometry.boundingBox.max.y - geometry.boundingBox.min.y
					let zLength = geometry.boundingBox.max.z - geometry.boundingBox.min.z

					let size = Math.min(xLength, yLength, zLength)
					if (object != null) {
						object.geometry = geometry
                        object.scale.set(10 / size, 10 / size, 10 / size)
						return
					}

                    const material = new THREE.MeshPhongMaterial({
                        color: 0x66BBFF,
                        side: THREE.DoubleSide,
                        depthTest: false,
                    })

                    object = new THREE.Mesh(geometry, material)
					object.position.set(0, 0, 0)
                    object.scale.set(10 / size, 10 / size, 10 / size)

                    scene.add(object)
				})
			}

			let createClock = function () {
				let clockGroup = new THREE.Group()
				const geometry = new THREE.CircleGeometry(38, 48)
				const material = new THREE.MeshBasicMaterial({
					color: 0x66BBFF,
					side: THREE.DoubleSide,
					opacity: 0.5,
					transparent: true
				})

				const clock = new THREE.Mesh(geometry, material)
				clockGroup.add(clock)

				touchGroup = new THREE.Group()
				for (let i = 0; i < 12; i++) {
					touchGroup.add(createTick(i))
				}

				clockGroup.add(touchGroup)
				clockGroup.add(createMarker())
				clockGroup.position.set(0, 40, 0)
				group.add(clockGroup)
			}

			const clock_tick = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']
			let createTick = function (i) {
				let tickGroup = new THREE.Group()
				const geometry = new THREE.CircleGeometry(6, 16)
				const material = new THREE.MeshPhongMaterial({
					color: 0x6666AA,
					side: THREE.DoubleSide,
				})

				const tick = new THREE.Mesh(geometry, material)
				tick.geometry.translate(Math.cos(Math.PI / 6 * i) * 30, Math.sin(Math.PI / 6 * i) * 30, 1)
				tick.name = i
				tick.layers.enable(1)
				tickGroup.add(tick)

				const textGeo = new THREE.TextGeometry(clock_tick[i], {
					font: font,
					size: 6,
					height: 6
				});

				const textMat = new THREE.MeshNormalMaterial({
				})

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();
				textGeo.center()

				let positionX = Math.cos(Math.PI / 6 * i) * 30
				let positionY = Math.sin(Math.PI / 6 * i) * 30
				textGeo.translate(positionX, positionY, 1)

				textMesh = new THREE.Mesh(textGeo, textMat);
				tickGroup.add(textMesh)

				return tickGroup
			}

			function createMarker() {
				let geometry, material, vertices
				let mGroup = new THREE.Group()
				vertices = new Float32Array(
					[
						0, 0, 2,
						2, 2, 0,
						0, 25, 2,
						0, 0, 2,
						0, 25, 2,
						-2, 2, 0,
					])

				material = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide })
				geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(vertices, 3))
				geometry.computeVertexNormals()
				second = new THREE.Mesh(geometry, material)
				mGroup.add(second)

				vertices = new Float32Array(
					[
						0, 0, 4,
						2, 2, 2,
						0, 20, 4,
						0, 0, 4,
						0, 20, 4,
						-2, 2, 2,
					])

				material = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide })
				geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(vertices, 3))
				geometry.computeVertexNormals()
				minute = new THREE.Mesh(geometry, material)
				mGroup.add(minute)

				vertices = new Float32Array(
					[
						0, 0, 6,
						2, 2, 4,
						0, 15, 6,
						0, 0, 6,
						0, 15, 6,
						-2, 2, 4,
					])

				material = new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide })
				geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(vertices, 3))
				geometry.computeVertexNormals()
				hour = new THREE.Mesh(geometry, material)
				mGroup.add(hour)

				return mGroup
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				aspect = window.innerWidth / window.innerHeight

				x_limit_l = 75 * aspect
				x_limit_r = -75 * aspect
				y_limit_t = 75 + 40
				y_limit_b = -75 + 40
			}

			function onDocumentKeyDown(event) {

				if (firstLetter) {

					firstLetter = false;
					text = '';

				}

				const keyCode = event.keyCode;

				// backspace

				if (keyCode === 8) {

					event.preventDefault();

					text = text.substring(0, text.length - 1);
					refreshText();

					return false;

				}

			}

			function onDocumentKeyPress(event) {

				const keyCode = event.which;

				// backspace

				if (keyCode === 8) {

					event.preventDefault();

				} else {

					const ch = String.fromCharCode(keyCode);
					text += ch;

					refreshText();

				}

			}

			function createText() {

				textGeo = new THREE.TextGeometry(text, {

					font: font,

					size: size,
					height: height,
					curveSegments: curveSegments,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: false

				});

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				const centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

				textMesh1 = new THREE.Mesh(textGeo, material);

				textMesh1.position.x = centerOffset;
				textMesh1.position.y = 0;
				textMesh1.position.z = 50;

				textMesh1.rotation.x = -Math.PI / 2;

				group.add(textMesh1);
			}

			function refreshText() {

				group.remove(textMesh1);
				if (mirror) group.remove(textMesh2);

				if (!text) return;

				createText();
			}

			function onPointerDown(event) {

				if (event.isPrimary === false) return;
				opstate = 0
				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;

				document.addEventListener('mousemove', onPointerMove);
				document.addEventListener('mouseup', onPointerUp);
			}

			function onPointerMove(event) {
				opstate = 1
				if (event.isPrimary === false) return;

				pointerX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
			}

			let loc = [
				'https://ntut-cg-lab.github.io/cg2021f-hw01-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw02-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw03-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw04-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw05-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw06-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw07-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw08-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw09-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw10-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw11-t109598067/',
				'https://ntut-cg-lab.github.io/cg2021f-hw12-t109598067/'
			]

			function onPointerUp(event) {

				if (event.isPrimary === false) return;
				if (opstate == 0) {
					mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
					mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
					// update the picking ray with the camera and mouse position
					raycaster.setFromCamera(mouse, camera);

					// calculate objects intersecting the picking ray
					const intersects = raycaster.intersectObjects(touchGroup.children, true);

					if (intersects.length > 0) {
						let index = intersects[0].object.name
						console.log(index)
						window.location = loc[index]
					}
				}

				opstate = -1
				document.removeEventListener('mousemove', onPointerMove);
				document.removeEventListener('mouseup', onPointerUp);
			}

			//

			function animate() {

				requestAnimationFrame(animate);
				let date = new Date()
				second.rotation.z = -date.getSeconds() / 30 * Math.PI
				minute.rotation.z = -date.getMinutes() / 30 * Math.PI
				hour.rotation.z = -date.getHours() / 6 * Math.PI
				group.rotation.y += (targetRotation - group.rotation.y) * 0.05;

				if (object != null) {
					object.position.x += velocity.x
					object.position.y += velocity.y
					object.position.z += velocity.z
					if (object.position.x > x_limit_l) {
						object.position.x = x_limit_l
						velocity.x = -velocity.x
					}
					else if (object.position.x < x_limit_r) {
						object.position.x = x_limit_r
						velocity.x = -velocity.x
					}
					if (object.position.y > y_limit_t) {
						object.position.y = y_limit_t
						velocity.y = -velocity.y
					}
					else if (object.position.y < y_limit_b) {
						object.position.y = y_limit_b
						velocity.y = -velocity.y
					}
				}


				camera.lookAt(cameraTarget);

				renderer.render(scene, camera);

			}

		</script>

	</body>
</html>
